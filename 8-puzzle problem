import heapq

goal = [(1,2,3),(4,5,6),(7,8,0)]

def manhattan(s):
    return sum(abs(i - x) + abs(j - y)
        for i, row in enumerate(s)
        for j, val in enumerate(row) if val != 0
        for x, r in enumerate(goal)
        for y, v in enumerate(r) if v == val)

def neighbors(state):
    i, j = next((r, c) for r in range(3) for c in range(3) if state[r][c] == 0)
    moves = [(-1,0),(1,0),(0,-1),(0,1)]
    for dr, dc in moves:
        r, c = i + dr, j + dc
        if 0 <= r < 3 and 0 <= c < 3:
            new = [list(row) for row in state]
            new[i][j], new[r][c] = new[r][c], new[i][j]
            yield tuple(tuple(row) for row in new)

def solve(start):
    start = tuple(tuple(row) for row in start)
    q = [(manhattan(start), 0, start, [])]
    seen = set()
    while q:
        est, cost, state, path = heapq.heappop(q)
        if state == tuple(goal): return path + [state]
        if state in seen: continue
        seen.add(state)
        for n in neighbors(state):
            heapq.heappush(q, (cost + 1 + manhattan(n), cost + 1, n, path + [state]))

def print_state(state):
    for row in state: print(' '.join(str(n) if n else '_' for n in row))
    print()

start = [[1,2,3],[4,0,6],[7,5,8]]
solution = solve(start)
for step in solution: print_state(step)
